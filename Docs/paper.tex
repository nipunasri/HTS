%\documentclass[9pt,twocolumn]{IEEEtran}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentclass[12pt,draft]{IEEEtran}
%\documentclass[11pt,draft]{IEEEtran}
%\documentclass[11pt,final]{IEEEtran}
%\documentclass[11pt,ds,final]{my_IEEEtran}
%\documentclass[11pt,onecolumn,draftcls]{IEEEtran}
%\documentclass[11pt]{IEEEtran}
\documentclass[11pt,onecolumn]{IEEEtran}
%\documentclass[draft]{IEEEtran}
%\documentclass[9pt,twocolumn,technote,twoside]{IEEEtran}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%\topmargin 0.125in

\usepackage{times}
\usepackage{subfigure}
%\usepackage{algorithmic}
\usepackage{algpseudocode}
\usepackage{algorithm}
%\renewcommand{\algorithmicrequire}{\textbf{Input:}}
%\renewcommand{\algorithmicensure}{\textbf{Output:}}

%\usepackage{epsfig}
%\usepackage{graphics,graphicx,fancyhdr,amsfonts,amsmath,color,epic}
\usepackage[dvips]{graphics,graphicx}
%\usepackage{graphicx,graphics}
\DeclareGraphicsExtensions{.jpg,.pdf,.eps,.png}

\newtheorem {lemma}{Lemma}
\newtheorem {theorem}{Theorem}

\begin{document}

\title{An OpenCL Implementation of Wait-Free Sets}

\author{Sudarshan Shinde \\
        Bangalore, INDIA. \\
Email:sudarshan\_shinde@iitbombay.org}

\maketitle

%\markboth{IEEE Transactions On Automatic Control, Vol. XX, No. Y, Month 1999}
%{Murray and Balemi: Using the style file IEEEtran.sty}

%\noindent EDICS No :DSP-BANK, DSP-MULT, DSP-TFSR.

%\thispagestyle{plain}
%\pagestyle{plain}

\begin{abstract}

\end{abstract}

\begin{IEEEkeywords}
wait-free programming, multithreading, gpgpu, opencl.
\end{IEEEkeywords}

\footnotetext{Copyright (c) 2010 IEEE. Personal use of this material is permitted. However, permission to use this material for any other purposes must be obtained from the IEEE by sending a request to pubs-permissions@ieee.org.}

\pagebreak

\section{Implementation Details}

The algorithms described in the literarure do not describe memory management. In perticular, they do not take into consideration, what happens if a node is physically deleted, while another process it using that node.

OpenCL 2.0 defines Shared Virtual Memory (SVM), that could be used to share data between host and the GPU device, without explicit data transfer. However OpenCL does not support dynamic data allocation on GPU side, and requires that size of SVM be pre-defined. This restricts maximum size of a set.

Since an implementation needs to take care of memory management, in this implementation we allocate a node pool of size $N$ in SVM. Though this restricts set size to be less than $N$, it still highlights many implementation aspects of wait-free set implementation in heterogenous computing setting.  

\section{The Algorithm}
The algorithm consists of a modification of the wait-free linked list to support replacing a node.

A {\it packed} reference consists of an unmarked reference, a {\it mark} bit to indicate if the node is marked and an {\it retain} bit to indicate that unmarked reference could not be changed. It also has a {\it free} bit to indicate that whether the node is occupied or free. These three bits are arranged as $Bits = [fBit,rBit,mBit]$.

We also have the following methods

\begin{enumerate}
    \item $[ref, bits] = unpackRef(pref)$.
\end{enumerate} 

\begin{algorithm}
  \caption{Snips next node if it is marked and could be snipped}
  \label{alg:snip}
  
  \begin{algorithmic}[1]
    %\Require
    %    \Statex startRef:Reference to the starting node.
    %\Ensure
    %   \Statex  next node will be snipped.
    %\Statex   
    \Function{snip}{startRef}
      \State pPRef = startRef:next;
      \State [nRef,pBits] = unpackRef(startRef:next);
      \If{(pBits = [0,0,x])}
        \State [nnRef,nBits] = unpackRef(nRef:next):
        \If{(nBits = [0,x,1])}
          \State status = CAS(startRef:next,pPRef,[nnRef,pBits]);
          \If{(status = true)}
             \State FREE(nRef);
             \State 
             \Return {\it snipped};
          \Else
             \State
             \Return {\it failed};
          \EndIf
        \Else
          \State
          \Return {\it next\_unmarked};
        \EndIf
      \Else
        \State
        \Return {\it start\_invalid};
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Replaces next node with a new node}
  \label{alg:replace}
  
  \begin{algorithmic}[1]
    %\Require
    %    \Statex startRef:Reference to the starting node.
    %\Ensure
    %   \Statex next node will be replaced by new node.
    \Statex   
    \Function{replace}{startRef, newRef}
      \State pPRef = startRef:next;    
      \State [nRef,pBits] = unpackRef(startRef:next);
      \If{([pBits] = [0,0,0])}
        \State nPRef = nRef:next;    
        \State [nnRef,nBits] = unpackRef(nRef:next);
        \If{(nBits = [0,x,0])}
          \State status = CAS(nRef:next,nPRef,[nnRef,[0,1,0]]);
          \If{(status = false)}
            \State
            \Return {\it retain\_failed};
          \EndIf  
        \Else
          \State
          \Return {\it invalid\_nbits};
        \EndIf
        \State newRef:next = [nnRef,[0,0,0]];
        \State status = CAS(startRef:next,pPRef,[newRef,pBits]);
        \If{(status = true)}
          \State FREE(nRef);
          \State
          \Return {\it replaced}; 
        \Else
          \State
          \Return {\it failed};
        \EndIf
      \Else
        \State
        \Return {\it invalid\_pbits};
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{cleans all the nodes that are logically deleted and could be physically deleted}
  \label{alg:clean}
  \begin{algorithmic}[1]
    %\Require
    %    \Statex startRef:Reference to the starting node.
    %\Ensure
    %   \Statex cleans all the logically deleted nodes.
    \Statex   
    \Function{clean}{startRef, nextRef\&}
      \State pRef  = startRef;
      \State nextRef  = {\it null};
      \While{(true)}
        \State status = snip(pRef);
        \State [nRef,pBits] = unpackRef(pRef:next);
        \If{(status = {\it next\_unmarked})}
          \State nextRef = nRef;
          \State
          \Return status;
        \ElsIf{status = {\it start\_invalid}}
          \If{(pBits = [0,1,x])}
            \State pRef = nRef; 
          \Else
            \If{(pRef = startRef)}
              \State
              \Return {\it start\_invalid}
            \Else
              \State pRef = startRef;  
            \EndIf
          \EndIf
        \EndIf
      \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{checks for valid window.}
  \label{alg:window}
  \begin{algorithmic}[1]
    %\Require
    %    \Statex startRef:Reference to the starting node.
    %\Ensure
    %   \Statex cleans all the logically deleted nodes.
    \Statex   
    \Function{window}{key, prevRef, nextRef, index\&}
      \State status = false;
      \If{(prevRef != {\it Null})}
        \State [nRef, pBits] = unpackRef(prevRef:next);
        \If{(pBits != [0,x,0])}
          \State 
          \Return {\it invalid\_prev\_bits}; ; 
        \EndIf
        \If{(nRef != nextRef)}
          \State 
          \Return {\it invalid\_next\_ref}; 
        \EndIf
        \State pMaxVal = simdMAX(prevRef:val);  
        \If{(key $<=$ pMaxVal)}
          \State 
          \Return {\it window\_not\_found};; 
        \EndIf
      \EndIf
      \State [nnRef, nBits] = unpackRef(nextRef:next);
      \If{(nBits != [0,x,0])}
        \State 
        \Return {\it invalid\_next\_bits}; 
      \EndIf
      \State pMaxVal = simdMAX(nextRef:val);  
      \If{(key $<=$ pMaxVal)}
        \State 
        \Return {\it window\_not\_found};
      \Else
        \If{(simdANY((key = nextRef:Val), index))}
          \State
          \Return {\it key\_found}
        \Else
          \State
          \Return {\it window\_found}
        \EndIf
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{finds a key and returns a window to it.}
  \label{alg:find}
  \begin{algorithmic}[1]
    \Require
        \Statex startRef:Reference to the starting node.
    \Ensure
       \Statex cleans all the logically deleted nodes.
    \Statex   
    \Function{find}{key, prevRef\&, nextRef\&, index\&}
      \State startRef = hash(key);
      \State prevRef = nextRef = {\it Null};
      \State index = 0;      
      \While(true)
        \State pRef = {\it Null};
        \State nRef = startRef;
        \State status = {\it window\_not\_found};
        \While{(status = {\it window\_not\_found})}
          \State status = WINDOW(key, pRef, nRef, index);
          \If{(status = {\it window\_not\_found})}
            \State pRef = nRef;
            \State status2 = CLEAN(pRef,nRef);
            \If{(status2 = {\it start\_invalid})}
              \State status = {\it window\_not\_found}
            \EndIf
          \EndIf
        \EndWhile
        \If{(status = {\it window\_found})}
          \State
          \Return status;
        \EndIf
        \If{(status = {\it key\_found})}
          \State
          \Return status;
        \EndIf
      \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}


\section{Proof of Correctness}

\begin{algorithm}
  \caption{Insert a key in the set}
  \label{alg:insert}
  \begin{algorithmic}[1]
    \Require
       \Statex {\it key} to be searched.
    \Ensure
       \Statex Returns {\it false} if key is found else inserts the {\it key}.
               
    \Statex
    \Function{insert}{key}
      \State doneFlag := false;
      \While{(!doneFlag)}
        \State findStatus := find(key, prevRef);
        \If{(findStaus = true)}
          \State
          \Return false;
        \EndIf
        \State [nextRef, prevMark] = getUnmarkedRef(prevRef);
        \If{(prevMark = 0)}
          \State insertStatus = false;
          \State minIndex := getMinEmptySlot(nextRef,nodePool);
          \If{(minIndex = 0)} \Comment No empty slot.
            \State insertStatus := insertNodeAndKey(key, prevRef,nextRef);
          \ElsIf{(minIndex > 0)}
            \State insertStatus := insertKey(key, minIndex, prevRef, nextRef);
          \EndIf
          \If{insertStatus = true}
            \State
            \Return true;
          \EndIf
        \EndIf
      \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Find empty slot with minimum index}
  \label{alg:minindex}
  \begin{algorithmic}[1]
    \Require
      \Statex {\it nextRef} in which minumum index to empty slot is to be
              found.
    \Ensure
      \Statex Returns {\it -1} if {\it nextRef} is deleted, {\it 0} if no
              empty slot is found, or minimum index to empty slot.  
    
    \Function{getMinEmptySlot}{nextRef}
      \State val := nextRef:V[lid];
      \State indicator := (val = EMPTY\_SLOT)?lid:0;
      \If {(simdALL(indicator = 0))}
        \State minIndex := 0;
      \Else
        \State minIndex := simdMIN(indicator);
      \EndIf
      \State [nnRef,nextMark] := getUnmarkedPtr(nextRef);
      \If{(nextMark = 0)}
        \State
        \Return minIndex;
      \Else
        \State
        \Return -1;
      \EndIf  
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Insert a node and a key}
  \label{alg:insnodekey}
  \begin{algorithmic}[1]
    \Require
      \Statex {\it key} to be inserted.
      \Statex {\it prefRef} and {\it nextRef} give window in which new node
              and key are to be inserted.
    \Ensure
       \Statex Returns {\it true} if successful.
    
    \Function{insertNodeAndKey}{key, prevRef, nextRef}
      \If{(lid = 1)} 
        \State newNRef := newNode();
        \State newNNRef := newNode();
      \EndIf
      \State simdBARRIER();
      \State newNRef  := simdBROADCAST(newNRef,1);
      \State newNNRef := simdBROADCAST(newNRef,1);      
      
      \State newNRef:next := [newNNRef,0];
      \If{(nodePool[nextRef]:V[lid] < key)}
        \State nodePool[newNRef]:V[lid] := nodePool[nextRef]:V[lid];
        \State nodePool[newNNRef]:V[lid] := EMPTY\_SLOT;
      \Else
        \State nodePool[newNNRef]:V[lid] := nodePool[nextRef]:V[lid];
        \State nodePool[newNPRef]:V[lid] := EMPTY\_SLOT;
      \EndIf
      \State minIndex := getMinEmptySlot(newNRef,nodePool);
      \State nodePool[newNRef]:V[minIndex] := key;
      \State nodePool[newNNPtr]:next := [nextRef,0];
      \State status := CAS(nodePool[prevRef]:next,[nextRef,0],newNPtr);
      \Return status;
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Insert a key in a node}
  \label{alg:inskey}
  \begin{algorithmic}[5]  
    \Function{insertKey}{key, minIndex, nextRef\&, nodePool}
      \If{lid = 1}
        \State status := CAS(nodePool[nextRef]:V[minIndex],EMPTY\_SLOT,key);
      \EndIf
      \State simdWait();
      \State status = simdBroadcast(status, 1);
      \Return status;
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Delete a key from the set}
  \label{alg:delkey}
  \begin{algorithmic}[5]  
    \Function{remove}{key, nodePool}
      \State doneFlag := false;
      \While{(!doneFlag)}
        \State findStatus := find(key, prevRef\&, nextRef\&, nodePool);
        \If{(findStaus = false)}
          \State
          \Return false;
        \EndIf
        \State val   := nodePool[nextRef]:V[lid];
        \If{(val = key)}
          \State status := CAS(nodePool[nextRef]:V[lid],key,EMPTY\_SLOT);
        \EndIf
        \State simdWait();
        \State status := simdBrodacast(status);
        \If{(status = true)}
          \State status := deleteNode(prevRef\&, nextRef\&, nodePool);
          \Return status;
        \Else
          \State
          \Return false;
        \EndIf
      \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Delete a node}
  \label{alg:delnode}
  \begin{algorithmic}[5]  
    \Function{deleteNode}{prevRef\&, nextRef\&, nodePool}
         \State val := nodePool[nextRef]:V[lid];
         \State status := simdAll(val,EMPTY\_SLOT);
         \If{(status = true)}
           \State [nnRef,nextMark] := getPtr(nextRef);
           \State newMark := 1;
           \If{(lid = 1)}
              \State status := CAS(nodePool[nextRef]:next,[nnRef,nextMark],[nnRef,newMark]);
              \If{(status = true)}
                \State status = delMarkedNodes(prevRef,NodePool); 
              \EndIf
           \EndIf
           \State simdWait();
           \State status = simdBroadcast(status,1);
           \State
           \Return status;
         \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

%\Bibliographystyle{ieeetr}
%\include{references.bbl}


%%%%%\bibliography{bib-file}  % commented if *.bbl file included, as seen below

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%  End of IEEEsample.tex  %%%%%%%%%%%%%%%%%%%%%%%%%%%
