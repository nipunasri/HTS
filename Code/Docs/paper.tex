%\documentclass[9pt,twocolumn]{IEEEtran}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentclass[12pt,draft]{IEEEtran}
%\documentclass[11pt,draft]{IEEEtran}
%\documentclass[11pt,final]{IEEEtran}
%\documentclass[11pt,ds,final]{my_IEEEtran}
\documentclass[11pt,onecolumn,draftcls]{IEEEtran}
%\documentclass[11pt]{IEEEtran}
%\documentclass[11pt]{IEEEtran}
%\documentclass[draft]{IEEEtran}
%\documentclass[9pt,twocolumn,technote,twoside]{IEEEtran}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%\topmargin 0.125in

\usepackage{times}
\usepackage{subfigure}
%\usepackage{algorithmic}
\usepackage{algpseudocode}
\usepackage{algorithm}

%\usepackage{epsfig}
%\usepackage{graphics,graphicx,fancyhdr,amsfonts,amsmath,color,epic}
\usepackage[dvips]{graphics,graphicx}
%\usepackage{graphicx,graphics}
\DeclareGraphicsExtensions{.jpg,.pdf,.eps,.png}

\newtheorem {lemma}{Lemma}
\newtheorem {theorem}{Theorem}

\begin{document}

\title{An OpenCL Implementation of Wait-Free Sets}

\author{Sudarshan Shinde \\
        Bangalore, INDIA. \\
Email:sudarshan\_shinde@iitbombay.org}

\maketitle

%\markboth{IEEE Transactions On Automatic Control, Vol. XX, No. Y, Month 1999}
%{Murray and Balemi: Using the style file IEEEtran.sty}

%\noindent EDICS No :DSP-BANK, DSP-MULT, DSP-TFSR.

%\thispagestyle{plain}
%\pagestyle{plain}

\begin{abstract}

\end{abstract}

\begin{IEEEkeywords}
wait-free programming, multithreading, gpgpu, opencl.
\end{IEEEkeywords}

\footnotetext{Copyright (c) 2010 IEEE. Personal use of this material is permitted. However, permission to use this material for any other purposes must be obtained from the IEEE by sending a request to pubs-permissions@ieee.org.}

\pagebreak

\section{Implementation Details}

The algorithms described in the literarure do not describe memory management. In perticular, they do not take into consideration, what happens if a node is physically deleted, while another process it using that node.

OpenCL 2.0 defines Shared Virtual Memory (SVM), that could be used to share data between host and the GPU device, without explicit data transfer. However OpenCL does not support dynamic data allocation on GPU side, and requires that size of SVM be pre-defined. This restricts maximum size of a set.

Since an implementation needs to take care of memory management, in this implementation we allocate a node pool of size $N$ in SVM. Though this restricts set size to be less than $N$, it still highlights many implementation aspects of wait-free set implementation in heterogenous computing setting.  

\section{Proof of Correctness}
{\fontsize{20}{20}
\begin{algorithm}
  \caption{Algorithm to delete marked nodes}
  \label{alg:deleteMarkedNode}
  \begin{algorithmic}[1]
    \Function{delMarkedNodes}{startRef, nextRef\&, nodePool}
      \State doneFlag = false;
      \While{(!doneFlag)}    
        \State [nextRef,startMark] := getPtr(startRef);
        \If{(!startMark)}
          \State [nextNextRef,nextMark] := getPtr(nextRef);
          \If{(nextMark)}
            \State casFlag = CAS(startRef:next,[nextRef,startMark],[nextNextRef,startMark]);
            \If{casFlag}
               \State PUT(nodePool,nextRef);
            \EndIf
          \Else
            \State
            \Return true;
          \EndIf
        \Else{}
          \State
          \Return false;  
        \EndIf
      \EndWhile        
    \EndFunction
  \end{algorithmic}
\end{algorithm}
}

\begin{theorem}
  If multiple threads are running algorithm \ref{alg:deleteMarkedNode}, then all of them will either return false, or return same unmarked nextRef.
\end{theorem}
\begin{proof}
  Consider the portion of the algorithm inside the while loop. It could be seen that the algorithm is trying to update the value of startRef:next. Each thread reads startRef:next at line 4, and atomically updates it at line 8. If multiple threads are updating it, only one thread will succeed, and so all the threads will have same value of startRef:next.

  Consider also that if some thread deletes startRef. This thread will also update startRef:next, making other threads running the algorithm return false.
\end{proof}

\begin{algorithm}
  \caption{Algorithm to find a key}
  \label{alg:find}
  \begin{algorithmic}[1]
    \Function{find}{key, nodePool}
       \State lid := getSIMDIndex();
       \State startRef := hashFunction(key);
       \State doneFlag := false;
       \While{(!doneFlag)}
          \State prevRef := startRef;
          \If{(lid = 1)}
             \State delStatus = delMarkedNode(prevRef,nextRef\&,nodePool);
          \EndIf
          \State waitAllSIMD();
          \State delStatus = broadcastSIMD(delStatus,1);
          \If{delStatus = true}
             \State maxVal = maxSIMD(nodePool,nextRef);
             \If{maxVal < key}
                \State prevRef = nextRef;
             \Else
                \State doneFlag = true;
                \If(anySIMD(val[lid] = key))
                   \Return true;
                \Else
                   \Return false;   
                \EndIf   
             \EndIf
          \Else
             \State prevRef = startRef;   
          \EndIf
       \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

%\Bibliographystyle{ieeetr}
%\include{references.bbl}


%%%%%\bibliography{bib-file}  % commented if *.bbl file included, as seen below

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%  End of IEEEsample.tex  %%%%%%%%%%%%%%%%%%%%%%%%%%%
